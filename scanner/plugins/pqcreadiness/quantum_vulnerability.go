// Copyright 2024 PQCA
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

package pqcreadiness

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"

	cdx "github.com/CycloneDX/cyclonedx-go"
)

// QuantumVulnerabilityStatus represents the quantum threat status of an algorithm
type QuantumVulnerabilityStatus string

const (
	// QuantumVulnerable - Algorithm is completely broken by quantum computers (Shor's algorithm)
	QuantumVulnerable QuantumVulnerabilityStatus = "quantum-vulnerable"
	// QuantumPartiallySecure - Algorithm has reduced security under quantum attack (Grover's algorithm)
	QuantumPartiallySecure QuantumVulnerabilityStatus = "quantum-partially-secure"
	// QuantumResistant - Algorithm maintains security (hash functions, larger symmetric keys)
	QuantumResistant QuantumVulnerabilityStatus = "quantum-resistant"
	// HybridTransitional - PQC+classical hybrid scheme (better than vulnerable, not fully quantum-safe)
	HybridTransitional QuantumVulnerabilityStatus = "hybrid-transitional"
	// QuantumSafe - True post-quantum cryptographic algorithm
	QuantumSafe QuantumVulnerabilityStatus = "quantum-safe"
	// QuantumUnknown - Unable to determine quantum status
	QuantumUnknown QuantumVulnerabilityStatus = "unknown"
)

// QuantumThreat represents the primary quantum threat to an algorithm
type QuantumThreat string

const (
	// ThreatShor - Shor's algorithm breaks RSA, ECC, DH, DSA
	ThreatShor QuantumThreat = "shors-algorithm"
	// ThreatGrover - Grover's algorithm reduces symmetric/hash security by half
	ThreatGrover QuantumThreat = "grovers-algorithm"
	// ThreatNone - No significant quantum threat
	ThreatNone QuantumThreat = "none"
	// ThreatUnknown - Unknown threat model
	ThreatUnknown QuantumThreat = "unknown"
)

// AlgorithmVulnerability contains quantum vulnerability information for an algorithm
type AlgorithmVulnerability struct {
	AlgorithmName          string
	AlgorithmFamily        string
	QuantumStatus          QuantumVulnerabilityStatus
	PrimaryThreat          QuantumThreat
	ClassicalSecurityBits  int
	QuantumSecurityBits    int
	NISTQuantumLevel       int
	Notes                  string
	RecommendedReplacement []string
}

// classifyQuantumVulnerability determines the quantum vulnerability of a component
func (plugin *Plugin) classifyQuantumVulnerability(component *cdx.Component) *AlgorithmVulnerability {
	// Extract algorithm information from component
	algName := extractAlgorithmName(component)
	keySize := extractKeySize(component)
	curve := extractCurve(component)
	oid := extractOID(component)

	// Look up in algorithm database
	if vulnInfo := plugin.algorithmDB.Lookup(algName, oid, keySize, curve); vulnInfo != nil {
		return vulnInfo
	}

	// Pattern matching for unknown algorithms
	return plugin.inferVulnerability(algName, keySize, curve, component)
}

// enrichWithVulnerability adds quantum vulnerability properties to a component
func (plugin *Plugin) enrichWithVulnerability(component *cdx.Component, vuln *AlgorithmVulnerability) {
	if component.Properties == nil {
		component.Properties = &[]cdx.Property{}
	}

	props := []cdx.Property{
		{
			Name:  "theia:pqc:quantum-status",
			Value: string(vuln.QuantumStatus),
		},
		{
			Name:  "theia:pqc:quantum-threat",
			Value: string(vuln.PrimaryThreat),
		},
		{
			Name:  "theia:pqc:classical-security-bits",
			Value: fmt.Sprintf("%d", vuln.ClassicalSecurityBits),
		},
		{
			Name:  "theia:pqc:quantum-security-bits",
			Value: fmt.Sprintf("%d", vuln.QuantumSecurityBits),
		},
		{
			Name:  "theia:pqc:nist-quantum-level",
			Value: fmt.Sprintf("%d", vuln.NISTQuantumLevel),
		},
	}

	if len(vuln.RecommendedReplacement) > 0 {
		props = append(props, cdx.Property{
			Name:  "theia:pqc:recommended-replacement",
			Value: strings.Join(vuln.RecommendedReplacement, ","),
		})
	}

	if vuln.Notes != "" {
		props = append(props, cdx.Property{
			Name:  "theia:pqc:vulnerability-notes",
			Value: vuln.Notes,
		})
	}

	*component.Properties = append(*component.Properties, props...)
}

// extractAlgorithmName extracts the algorithm name from a component
func extractAlgorithmName(component *cdx.Component) string {
	// First try the component name
	if component.Name != "" {
		return component.Name
	}

	// Check crypto properties
	if component.CryptoProperties != nil && component.CryptoProperties.AlgorithmProperties != nil {
		if component.CryptoProperties.AlgorithmProperties.ParameterSetIdentifier != "" {
			return component.CryptoProperties.AlgorithmProperties.ParameterSetIdentifier
		}
	}

	return ""
}

// extractKeySize extracts the key size from a component
func extractKeySize(component *cdx.Component) int {
	// Try to extract from component name (e.g., "RSA-2048", "AES-256")
	name := strings.ToUpper(component.Name)

	// Common patterns
	patterns := []string{
		`RSA[- ]?(\d+)`,
		`AES[- ]?(\d+)`,
		`DSA[- ]?(\d+)`,
		`(\d+)[- ]?BIT`,
	}

	for _, pattern := range patterns {
		re := regexp.MustCompile(pattern)
		if matches := re.FindStringSubmatch(name); len(matches) > 1 {
			if size, err := strconv.Atoi(matches[1]); err == nil {
				return size
			}
		}
	}

	// Check crypto properties for parameter set
	if component.CryptoProperties != nil && component.CryptoProperties.AlgorithmProperties != nil {
		paramSet := component.CryptoProperties.AlgorithmProperties.ParameterSetIdentifier
		if paramSet != "" {
			if size, err := strconv.Atoi(paramSet); err == nil {
				return size
			}
		}
	}

	return 0
}

// extractCurve extracts the elliptic curve from a component
func extractCurve(component *cdx.Component) string {
	name := strings.ToUpper(component.Name)

	// Common curve patterns
	curves := []string{"P-256", "P-384", "P-521", "SECP256R1", "SECP384R1", "SECP521R1", "ED25519", "ED448", "X25519", "X448"}
	for _, curve := range curves {
		if strings.Contains(name, curve) {
			return curve
		}
	}

	// Check crypto properties
	if component.CryptoProperties != nil && component.CryptoProperties.AlgorithmProperties != nil {
		if component.CryptoProperties.AlgorithmProperties.Curve != "" {
			return component.CryptoProperties.AlgorithmProperties.Curve
		}
	}

	return ""
}

// extractOID extracts the OID from a component
func extractOID(component *cdx.Component) string {
	if component.CryptoProperties != nil && component.CryptoProperties.OID != "" {
		return component.CryptoProperties.OID
	}
	return ""
}

// inferVulnerability infers quantum vulnerability from algorithm patterns
func (plugin *Plugin) inferVulnerability(algName string, keySize int, curve string, component *cdx.Component) *AlgorithmVulnerability {
	upperName := strings.ToUpper(algName)

	// RSA patterns
	if strings.Contains(upperName, "RSA") {
		return plugin.inferRSAVulnerability(keySize)
	}

	// ECDSA/ECDH patterns
	if strings.Contains(upperName, "ECDSA") || strings.Contains(upperName, "ECDH") || strings.Contains(upperName, "EC") {
		return plugin.inferECVulnerability(curve)
	}

	// DSA patterns
	if strings.Contains(upperName, "DSA") && !strings.Contains(upperName, "ECDSA") {
		return plugin.inferDSAVulnerability(keySize)
	}

	// DH patterns
	if strings.Contains(upperName, "DH") && !strings.Contains(upperName, "ECDH") {
		return plugin.inferDHVulnerability(keySize)
	}

	// Ed25519/Ed448
	if strings.Contains(upperName, "ED25519") || strings.Contains(upperName, "ED448") {
		return &AlgorithmVulnerability{
			AlgorithmName:          algName,
			AlgorithmFamily:        "EdDSA",
			QuantumStatus:          QuantumVulnerable,
			PrimaryThreat:          ThreatShor,
			ClassicalSecurityBits:  128,
			QuantumSecurityBits:    0,
			NISTQuantumLevel:       0,
			RecommendedReplacement: []string{"ML-DSA-65", "SLH-DSA-SHA2-128f"},
		}
	}

	// AES patterns
	if strings.Contains(upperName, "AES") {
		return plugin.inferAESVulnerability(keySize)
	}

	// SHA patterns
	if strings.Contains(upperName, "SHA") {
		return plugin.inferSHAVulnerability(algName)
	}

	// 3DES
	if strings.Contains(upperName, "3DES") || strings.Contains(upperName, "TRIPLE") {
		return &AlgorithmVulnerability{
			AlgorithmName:          algName,
			AlgorithmFamily:        "3DES",
			QuantumStatus:          QuantumPartiallySecure,
			PrimaryThreat:          ThreatGrover,
			ClassicalSecurityBits:  112,
			QuantumSecurityBits:    56,
			NISTQuantumLevel:       0,
			Notes:                  "3DES is deprecated; quantum security is theoretical as algorithm is obsolete",
			RecommendedReplacement: []string{"AES-256"},
		}
	}

	// ChaCha20
	if strings.Contains(upperName, "CHACHA") {
		return &AlgorithmVulnerability{
			AlgorithmName:         algName,
			AlgorithmFamily:       "ChaCha",
			QuantumStatus:         QuantumResistant,
			PrimaryThreat:         ThreatGrover,
			ClassicalSecurityBits: 256,
			QuantumSecurityBits:   128,
			NISTQuantumLevel:      3,
		}
	}

	// Unknown algorithm
	return &AlgorithmVulnerability{
		AlgorithmName:   algName,
		AlgorithmFamily: "unknown",
		QuantumStatus:   QuantumUnknown,
		PrimaryThreat:   ThreatUnknown,
		Notes:           "Unable to determine quantum vulnerability for this algorithm",
	}
}

func (plugin *Plugin) inferRSAVulnerability(keySize int) *AlgorithmVulnerability {
	vuln := &AlgorithmVulnerability{
		AlgorithmFamily:        "RSA",
		QuantumStatus:          QuantumVulnerable,
		PrimaryThreat:          ThreatShor,
		QuantumSecurityBits:    0,
		NISTQuantumLevel:       0,
		RecommendedReplacement: []string{"ML-KEM-768", "ML-DSA-65"},
	}

	switch {
	case keySize >= 4096:
		vuln.AlgorithmName = fmt.Sprintf("RSA-%d", keySize)
		vuln.ClassicalSecurityBits = 152
	case keySize >= 3072:
		vuln.AlgorithmName = fmt.Sprintf("RSA-%d", keySize)
		vuln.ClassicalSecurityBits = 128
	case keySize >= 2048:
		vuln.AlgorithmName = fmt.Sprintf("RSA-%d", keySize)
		vuln.ClassicalSecurityBits = 112
	case keySize >= 1024:
		vuln.AlgorithmName = fmt.Sprintf("RSA-%d", keySize)
		vuln.ClassicalSecurityBits = 80
		vuln.Notes = "RSA-1024 is considered weak even classically"
	default:
		vuln.AlgorithmName = "RSA"
		vuln.ClassicalSecurityBits = 112 // Assume 2048 as default
	}

	return vuln
}

func (plugin *Plugin) inferECVulnerability(curve string) *AlgorithmVulnerability {
	vuln := &AlgorithmVulnerability{
		AlgorithmFamily:        "ECC",
		QuantumStatus:          QuantumVulnerable,
		PrimaryThreat:          ThreatShor,
		QuantumSecurityBits:    0,
		NISTQuantumLevel:       0,
		RecommendedReplacement: []string{"ML-DSA-65", "ML-KEM-768"},
	}

	switch strings.ToUpper(curve) {
	case "P-256", "SECP256R1", "PRIME256V1":
		vuln.AlgorithmName = "ECDSA-P256"
		vuln.ClassicalSecurityBits = 128
	case "P-384", "SECP384R1":
		vuln.AlgorithmName = "ECDSA-P384"
		vuln.ClassicalSecurityBits = 192
		vuln.RecommendedReplacement = []string{"ML-DSA-87", "ML-KEM-1024"}
	case "P-521", "SECP521R1":
		vuln.AlgorithmName = "ECDSA-P521"
		vuln.ClassicalSecurityBits = 256
		vuln.RecommendedReplacement = []string{"ML-DSA-87", "ML-KEM-1024"}
	default:
		vuln.AlgorithmName = "ECDSA"
		vuln.ClassicalSecurityBits = 128 // Assume P-256 as default
	}

	return vuln
}

func (plugin *Plugin) inferDSAVulnerability(keySize int) *AlgorithmVulnerability {
	vuln := &AlgorithmVulnerability{
		AlgorithmFamily:        "DSA",
		QuantumStatus:          QuantumVulnerable,
		PrimaryThreat:          ThreatShor,
		QuantumSecurityBits:    0,
		NISTQuantumLevel:       0,
		RecommendedReplacement: []string{"ML-DSA-65"},
	}

	switch {
	case keySize >= 3072:
		vuln.AlgorithmName = fmt.Sprintf("DSA-%d", keySize)
		vuln.ClassicalSecurityBits = 128
	case keySize >= 2048:
		vuln.AlgorithmName = fmt.Sprintf("DSA-%d", keySize)
		vuln.ClassicalSecurityBits = 112
	default:
		vuln.AlgorithmName = "DSA"
		vuln.ClassicalSecurityBits = 112
	}

	return vuln
}

func (plugin *Plugin) inferDHVulnerability(keySize int) *AlgorithmVulnerability {
	vuln := &AlgorithmVulnerability{
		AlgorithmFamily:        "DH",
		QuantumStatus:          QuantumVulnerable,
		PrimaryThreat:          ThreatShor,
		QuantumSecurityBits:    0,
		NISTQuantumLevel:       0,
		RecommendedReplacement: []string{"ML-KEM-768"},
	}

	switch {
	case keySize >= 4096:
		vuln.AlgorithmName = fmt.Sprintf("DH-%d", keySize)
		vuln.ClassicalSecurityBits = 152
	case keySize >= 3072:
		vuln.AlgorithmName = fmt.Sprintf("DH-%d", keySize)
		vuln.ClassicalSecurityBits = 128
	case keySize >= 2048:
		vuln.AlgorithmName = fmt.Sprintf("DH-%d", keySize)
		vuln.ClassicalSecurityBits = 112
	default:
		vuln.AlgorithmName = "DH"
		vuln.ClassicalSecurityBits = 112
	}

	return vuln
}

func (plugin *Plugin) inferAESVulnerability(keySize int) *AlgorithmVulnerability {
	vuln := &AlgorithmVulnerability{
		AlgorithmFamily: "AES",
		QuantumStatus:   QuantumPartiallySecure,
		PrimaryThreat:   ThreatGrover,
	}

	switch {
	case keySize >= 256:
		vuln.AlgorithmName = "AES-256"
		vuln.ClassicalSecurityBits = 256
		vuln.QuantumSecurityBits = 128
		vuln.NISTQuantumLevel = 3
		vuln.QuantumStatus = QuantumResistant
	case keySize >= 192:
		vuln.AlgorithmName = "AES-192"
		vuln.ClassicalSecurityBits = 192
		vuln.QuantumSecurityBits = 96
		vuln.NISTQuantumLevel = 2
	case keySize >= 128:
		vuln.AlgorithmName = "AES-128"
		vuln.ClassicalSecurityBits = 128
		vuln.QuantumSecurityBits = 64
		vuln.NISTQuantumLevel = 1
		vuln.Notes = "Consider upgrading to AES-256 for post-quantum security"
		vuln.RecommendedReplacement = []string{"AES-256"}
	default:
		vuln.AlgorithmName = "AES"
		vuln.ClassicalSecurityBits = 128
		vuln.QuantumSecurityBits = 64
		vuln.NISTQuantumLevel = 1
	}

	return vuln
}

func (plugin *Plugin) inferSHAVulnerability(algName string) *AlgorithmVulnerability {
	upperName := strings.ToUpper(algName)

	vuln := &AlgorithmVulnerability{
		AlgorithmFamily: "SHA",
		QuantumStatus:   QuantumResistant,
		PrimaryThreat:   ThreatGrover,
	}

	switch {
	case strings.Contains(upperName, "SHA3-512") || strings.Contains(upperName, "SHA-3-512"):
		vuln.AlgorithmName = "SHA3-512"
		vuln.ClassicalSecurityBits = 256
		vuln.QuantumSecurityBits = 256
		vuln.NISTQuantumLevel = 5
	case strings.Contains(upperName, "SHA3-384") || strings.Contains(upperName, "SHA-3-384"):
		vuln.AlgorithmName = "SHA3-384"
		vuln.ClassicalSecurityBits = 192
		vuln.QuantumSecurityBits = 192
		vuln.NISTQuantumLevel = 3
	case strings.Contains(upperName, "SHA3-256") || strings.Contains(upperName, "SHA-3-256"):
		vuln.AlgorithmName = "SHA3-256"
		vuln.ClassicalSecurityBits = 128
		vuln.QuantumSecurityBits = 128
		vuln.NISTQuantumLevel = 1
	case strings.Contains(upperName, "SHA512") || strings.Contains(upperName, "SHA-512"):
		vuln.AlgorithmName = "SHA-512"
		vuln.ClassicalSecurityBits = 256
		vuln.QuantumSecurityBits = 256
		vuln.NISTQuantumLevel = 5
	case strings.Contains(upperName, "SHA384") || strings.Contains(upperName, "SHA-384"):
		vuln.AlgorithmName = "SHA-384"
		vuln.ClassicalSecurityBits = 192
		vuln.QuantumSecurityBits = 192
		vuln.NISTQuantumLevel = 3
	case strings.Contains(upperName, "SHA256") || strings.Contains(upperName, "SHA-256"):
		vuln.AlgorithmName = "SHA-256"
		vuln.ClassicalSecurityBits = 128
		vuln.QuantumSecurityBits = 128
		vuln.NISTQuantumLevel = 1
	case strings.Contains(upperName, "SHA1") || strings.Contains(upperName, "SHA-1"):
		vuln.AlgorithmName = "SHA-1"
		vuln.ClassicalSecurityBits = 80
		vuln.QuantumSecurityBits = 80
		vuln.NISTQuantumLevel = 0
		vuln.Notes = "SHA-1 is deprecated for cryptographic use"
		vuln.RecommendedReplacement = []string{"SHA-256", "SHA3-256"}
	case strings.Contains(upperName, "MD5"):
		vuln.AlgorithmName = "MD5"
		vuln.AlgorithmFamily = "MD5"
		vuln.ClassicalSecurityBits = 64
		vuln.QuantumSecurityBits = 64
		vuln.NISTQuantumLevel = 0
		vuln.Notes = "MD5 is broken and should not be used"
		vuln.RecommendedReplacement = []string{"SHA-256", "SHA3-256"}
	default:
		vuln.AlgorithmName = algName
		vuln.ClassicalSecurityBits = 128
		vuln.QuantumSecurityBits = 128
		vuln.NISTQuantumLevel = 1
	}

	return vuln
}
